"use strict";(globalThis.webpackChunkbook=globalThis.webpackChunkbook||[]).push([[692],{6782:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>t,metadata:()=>o,toc:()=>c});var s=i(4848),r=i(8453);const t={sidebar_position:4,title:"Chapter 3 Exercises"},l="Chapter 3: Exercises",o={id:"chapter-03/exercises",title:"Chapter 3 Exercises",description:"Exercise 3.1: Basic Gazebo Environment",source:"@site/docs/chapter-03/04-exercises.md",sourceDirName:"chapter-03",slug:"/chapter-03/exercises",permalink:"/docs/chapter-03/exercises",draft:!1,unlisted:!1,editUrl:"https://github.com/tabindaseher/Physical-AI-Humanoid-Robotics/edit/main/docs/chapter-03/04-exercises.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4,title:"Chapter 3 Exercises"},sidebar:"tutorialSidebar",previous:{title:"Chapter 3 Key Concepts",permalink:"/docs/chapter-03/key-concepts"},next:{title:"Chapter 4: Backend - The AI-Robot Brain (NVIDIA Isaac)",permalink:"/docs/chapter-04/nvidia-isaac-ai-brain"}},a={},c=[{value:"Exercise 3.1: Basic Gazebo Environment",id:"exercise-31-basic-gazebo-environment",level:2},{value:"Exercise 3.2: Unity Robot Integration",id:"exercise-32-unity-robot-integration",level:2},{value:"Exercise 3.3: Domain Randomization",id:"exercise-33-domain-randomization",level:2},{value:"Exercise 3.4: Multi-Simulation Comparison",id:"exercise-34-multi-simulation-comparison",level:2},{value:"Exercise 3.5: Digital Twin Validation",id:"exercise-35-digital-twin-validation",level:2},{value:"Exercise 3.6: Sensor Simulation Enhancement",id:"exercise-36-sensor-simulation-enhancement",level:2},{value:"Exercise 3.7: Physics Parameter Tuning",id:"exercise-37-physics-parameter-tuning",level:2},{value:"Self-Assessment Checklist",id:"self-assessment-checklist",level:2},{value:"Solutions Guide (Instructor Access)",id:"solutions-guide-instructor-access",level:2},{value:"Exercise 3.1 Expected Components",id:"exercise-31-expected-components",level:3},{value:"Exercise 3.2 Unity Implementation Hints",id:"exercise-32-unity-implementation-hints",level:3},{value:"Exercise 3.3 Domain Randomization Approach",id:"exercise-33-domain-randomization-approach",level:3}];function d(e){const n={br:"br",h1:"h1",h2:"h2",h3:"h3",hr:"hr",input:"input",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"chapter-3-exercises",children:"Chapter 3: Exercises"}),"\n",(0,s.jsx)(n.h2,{id:"exercise-31-basic-gazebo-environment",children:"Exercise 3.1: Basic Gazebo Environment"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Difficulty Level"}),": Basic",(0,s.jsx)(n.br,{}),"\n",(0,s.jsx)(n.strong,{children:"Time Required"}),": 60 minutes",(0,s.jsx)(n.br,{}),"\n",(0,s.jsx)(n.strong,{children:"Learning Objective"}),": Remember & Apply"]}),"\n",(0,s.jsx)(n.p,{children:"Create a simple Gazebo world with a robot model and basic sensors. Implement a ROS 2 node that controls the robot to navigate through the environment."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Instructions:"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Create a simple robot model using URDF/SDF with a base and wheels"}),"\n",(0,s.jsx)(n.li,{children:"Add basic sensors (at least camera and IMU) to the robot model"}),"\n",(0,s.jsx)(n.li,{children:"Create a Gazebo world file with simple obstacles"}),"\n",(0,s.jsx)(n.li,{children:"Implement a ROS 2 node that publishes velocity commands to move the robot"}),"\n",(0,s.jsx)(n.li,{children:"Test the robot's navigation in the simulated environment"}),"\n",(0,s.jsx)(n.li,{children:"Document the robot's sensor data and movement patterns"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Submission Requirements:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Robot URDF/SDF model files"}),"\n",(0,s.jsx)(n.li,{children:"World file with obstacles"}),"\n",(0,s.jsx)(n.li,{children:"ROS 2 control node implementation"}),"\n",(0,s.jsx)(n.li,{children:"Launch file to start the complete simulation"}),"\n",(0,s.jsx)(n.li,{children:"Test results and documentation"}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"exercise-32-unity-robot-integration",children:"Exercise 3.2: Unity Robot Integration"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Difficulty Level"}),": Intermediate",(0,s.jsx)(n.br,{}),"\n",(0,s.jsx)(n.strong,{children:"Time Required"}),": 90 minutes",(0,s.jsx)(n.br,{}),"\n",(0,s.jsx)(n.strong,{children:"Learning Objective"}),": Apply & Understand"]}),"\n",(0,s.jsx)(n.p,{children:"Set up a Unity simulation with the Robotics SDK and create a basic robot that responds to ROS messages for movement control."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Instructions:"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Install Unity Robotics SDK and set up ROS connection"}),"\n",(0,s.jsx)(n.li,{children:"Create a simple robot model in Unity with wheels or joints"}),"\n",(0,s.jsx)(n.li,{children:"Implement ROS message handling for control commands"}),"\n",(0,s.jsx)(n.li,{children:"Create a Unity script that converts ROS messages to Unity physics"}),"\n",(0,s.jsx)(n.li,{children:"Test the robot's response to various control commands"}),"\n",(0,s.jsx)(n.li,{children:"Validate the coordinate system conversion between ROS and Unity"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Key Components to Implement:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"ROS connection management in Unity"}),"\n",(0,s.jsx)(n.li,{children:"Message subscription and publication"}),"\n",(0,s.jsx)(n.li,{children:"Physics-based robot movement"}),"\n",(0,s.jsx)(n.li,{children:"Coordinate system conversion"}),"\n",(0,s.jsx)(n.li,{children:"Visual feedback and debugging"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Submission Requirements:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Unity project with robot model"}),"\n",(0,s.jsx)(n.li,{children:"ROS communication scripts"}),"\n",(0,s.jsx)(n.li,{children:"Physics implementation"}),"\n",(0,s.jsx)(n.li,{children:"Testing documentation with results"}),"\n",(0,s.jsx)(n.li,{children:"Coordinate conversion validation"}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"exercise-33-domain-randomization",children:"Exercise 3.3: Domain Randomization"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Difficulty Level"}),": Advanced",(0,s.jsx)(n.br,{}),"\n",(0,s.jsx)(n.strong,{children:"Time Required"}),": 120 minutes",(0,s.jsx)(n.br,{}),"\n",(0,s.jsx)(n.strong,{children:"Learning Objective"}),": Analyze & Create"]}),"\n",(0,s.jsx)(n.p,{children:"Implement domain randomization in either Gazebo or Unity to improve the robustness of a control policy."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Instructions:"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Choose either Gazebo or Unity environment for the exercise"}),"\n",(0,s.jsx)(n.li,{children:"Create a simple control task (e.g., maintaining balance, reaching a target)"}),"\n",(0,s.jsxs)(n.li,{children:["Implement domain randomization for at least 3 different parameters:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Physical properties (friction, mass, etc.)"}),"\n",(0,s.jsx)(n.li,{children:"Visual properties (lighting, textures, colors)"}),"\n",(0,s.jsx)(n.li,{children:"Sensor properties (noise levels, calibration)"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.li,{children:"Train a simple controller in the randomized environment"}),"\n",(0,s.jsx)(n.li,{children:"Test the controller's performance in a fixed environment"}),"\n",(0,s.jsx)(n.li,{children:"Compare with a controller trained without domain randomization"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters to Randomize:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Friction coefficients"}),"\n",(0,s.jsx)(n.li,{children:"Mass multipliers"}),"\n",(0,s.jsx)(n.li,{children:"Gravity variations"}),"\n",(0,s.jsx)(n.li,{children:"Sensor noise levels"}),"\n",(0,s.jsx)(n.li,{children:"Visual appearance"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Submission Requirements:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Domain randomization implementation"}),"\n",(0,s.jsx)(n.li,{children:"Control policy training code"}),"\n",(0,s.jsx)(n.li,{children:"Performance comparison analysis"}),"\n",(0,s.jsx)(n.li,{children:"Randomization parameter ranges"}),"\n",(0,s.jsx)(n.li,{children:"Results documentation"}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"exercise-34-multi-simulation-comparison",children:"Exercise 3.4: Multi-Simulation Comparison"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Difficulty Level"}),": Advanced",(0,s.jsx)(n.br,{}),"\n",(0,s.jsx)(n.strong,{children:"Time Required"}),": 150 minutes",(0,s.jsx)(n.br,{}),"\n",(0,s.jsx)(n.strong,{children:"Learning Objective"}),": Analyze & Evaluate"]}),"\n",(0,s.jsx)(n.p,{children:"Compare the same robot model running in both Gazebo and Unity, analyzing differences in sensor output and physical behavior."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Instructions:"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Create a simple robot model that can run in both Gazebo and Unity"}),"\n",(0,s.jsx)(n.li,{children:"Implement the same control algorithm in both environments"}),"\n",(0,s.jsx)(n.li,{children:"Execute identical control commands in both simulations"}),"\n",(0,s.jsx)(n.li,{children:"Log and compare sensor outputs (position, velocity, IMU, etc.)"}),"\n",(0,s.jsx)(n.li,{children:"Analyze differences in physical behavior and sensor readings"}),"\n",(0,s.jsx)(n.li,{children:"Document the sources of differences and their implications"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Comparison Metrics:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Position and orientation tracking accuracy"}),"\n",(0,s.jsx)(n.li,{children:"Sensor noise characteristics"}),"\n",(0,s.jsx)(n.li,{children:"Physics simulation differences"}),"\n",(0,s.jsx)(n.li,{children:"Computational performance"}),"\n",(0,s.jsx)(n.li,{children:"Real-time capability"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Submission Requirements:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Robot model for both environments"}),"\n",(0,s.jsx)(n.li,{children:"Control algorithm implementation"}),"\n",(0,s.jsx)(n.li,{children:"Data logging and comparison tools"}),"\n",(0,s.jsx)(n.li,{children:"Analysis of differences and their sources"}),"\n",(0,s.jsx)(n.li,{children:"Performance benchmarking results"}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"exercise-35-digital-twin-validation",children:"Exercise 3.5: Digital Twin Validation"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Difficulty Level"}),": Advanced",(0,s.jsx)(n.br,{}),"\n",(0,s.jsx)(n.strong,{children:"Time Required"}),": 180 minutes",(0,s.jsx)(n.br,{}),"\n",(0,s.jsx)(n.strong,{children:"Learning Objective"}),": Evaluate & Create"]}),"\n",(0,s.jsx)(n.p,{children:"Design and implement a validation framework to compare simulation results with real-world robot performance."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Instructions:"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Identify a specific robot behavior or task for validation"}),"\n",(0,s.jsx)(n.li,{children:"Design a validation methodology with appropriate metrics"}),"\n",(0,s.jsx)(n.li,{children:"Implement data collection from both simulation and real robot"}),"\n",(0,s.jsx)(n.li,{children:"Create tools to compare the datasets quantitatively"}),"\n",(0,s.jsx)(n.li,{children:"Evaluate the fidelity of your simulation model"}),"\n",(0,s.jsx)(n.li,{children:"Propose improvements to increase simulation accuracy"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Validation Components:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Kinematic validation: forward and inverse kinematics"}),"\n",(0,s.jsx)(n.li,{children:"Dynamic validation: mass, inertia, friction parameters"}),"\n",(0,s.jsx)(n.li,{children:"Sensor validation: comparing sensor outputs"}),"\n",(0,s.jsx)(n.li,{children:"Control validation: control algorithm performance"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Metrics to Calculate:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Position error between simulation and reality"}),"\n",(0,s.jsx)(n.li,{children:"Velocity tracking accuracy"}),"\n",(0,s.jsx)(n.li,{children:"Sensor output correlation"}),"\n",(0,s.jsx)(n.li,{children:"Task completion success rate"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Submission Requirements:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Validation framework design and implementation"}),"\n",(0,s.jsx)(n.li,{children:"Data collection tools for both environments"}),"\n",(0,s.jsx)(n.li,{children:"Quantitative comparison analysis"}),"\n",(0,s.jsx)(n.li,{children:"Validation results and simulation fidelity assessment"}),"\n",(0,s.jsx)(n.li,{children:"Recommendations for simulation improvements"}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"exercise-36-sensor-simulation-enhancement",children:"Exercise 3.6: Sensor Simulation Enhancement"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Difficulty Level"}),": Intermediate",(0,s.jsx)(n.br,{}),"\n",(0,s.jsx)(n.strong,{children:"Time Required"}),": 75 minutes",(0,s.jsx)(n.br,{}),"\n",(0,s.jsx)(n.strong,{children:"Learning Objective"}),": Apply & Analyze"]}),"\n",(0,s.jsx)(n.p,{children:"Enhance the sensor simulation in Gazebo by creating custom sensor models with realistic noise models."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Instructions:"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Create a custom sensor model in Gazebo (e.g., custom LIDAR or camera)"}),"\n",(0,s.jsx)(n.li,{children:"Implement realistic noise models based on actual sensor specifications"}),"\n",(0,s.jsx)(n.li,{children:"Add sensor-specific parameters that can be configured through ROS"}),"\n",(0,s.jsx)(n.li,{children:"Test the sensor model with different parameter configurations"}),"\n",(0,s.jsx)(n.li,{children:"Compare the simulated sensor output with real sensor data if available"}),"\n",(0,s.jsx)(n.li,{children:"Analyze the impact of different noise levels on robot performance"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Sensor Enhancement Requirements:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Custom sensor plugin development"}),"\n",(0,s.jsx)(n.li,{children:"Realistic noise model implementation"}),"\n",(0,s.jsx)(n.li,{children:"Parameter configurability"}),"\n",(0,s.jsx)(n.li,{children:"ROS integration for parameter control"}),"\n",(0,s.jsx)(n.li,{children:"Performance analysis"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Submission Requirements:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Custom sensor plugin code"}),"\n",(0,s.jsx)(n.li,{children:"Noise model implementation"}),"\n",(0,s.jsx)(n.li,{children:"Parameter configuration system"}),"\n",(0,s.jsx)(n.li,{children:"Test results and performance analysis"}),"\n",(0,s.jsx)(n.li,{children:"Realism assessment"}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"exercise-37-physics-parameter-tuning",children:"Exercise 3.7: Physics Parameter Tuning"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Difficulty Level"}),": Intermediate",(0,s.jsx)(n.br,{}),"\n",(0,s.jsx)(n.strong,{children:"Time Required"}),": 100 minutes",(0,s.jsx)(n.br,{}),"\n",(0,s.jsx)(n.strong,{children:"Learning Objective"}),": Apply & Evaluate"]}),"\n",(0,s.jsx)(n.p,{children:"Tune physics parameters in Gazebo to match real-world robot behavior."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Instructions:"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Identify key physics parameters that affect your robot's behavior"}),"\n",(0,s.jsx)(n.li,{children:"Design experiments to determine real-world parameter values"}),"\n",(0,s.jsx)(n.li,{children:"Implement parameter tuning methodology in simulation"}),"\n",(0,s.jsx)(n.li,{children:"Adjust parameters to match real-world behavior"}),"\n",(0,s.jsx)(n.li,{children:"Validate the tuned model with additional tests"}),"\n",(0,s.jsx)(n.li,{children:"Document the tuning process and results"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters to Tune:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Friction coefficients"}),"\n",(0,s.jsx)(n.li,{children:"Mass and inertia parameters"}),"\n",(0,s.jsx)(n.li,{children:"Joint damping and stiffness"}),"\n",(0,s.jsx)(n.li,{children:"Contact parameters"}),"\n",(0,s.jsx)(n.li,{children:"Motor characteristics"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Submission Requirements:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Parameter identification methodology"}),"\n",(0,s.jsx)(n.li,{children:"Tuning algorithm implementation"}),"\n",(0,s.jsx)(n.li,{children:"Before and after comparison"}),"\n",(0,s.jsx)(n.li,{children:"Validation test results"}),"\n",(0,s.jsx)(n.li,{children:"Tuning process documentation"}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"self-assessment-checklist",children:"Self-Assessment Checklist"}),"\n",(0,s.jsx)(n.p,{children:"After completing these exercises, you should:"}),"\n",(0,s.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Understand the fundamental concepts of digital twins in robotics"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Be able to set up simulation environments in both Gazebo and Unity"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Know how to implement domain randomization techniques"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Understand the differences between simulation environments"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Be able to validate simulation models against real-world data"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Know how to tune physics parameters for better realism"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Understand sim-to-real transfer challenges and solutions"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Be able to create comprehensive validation frameworks"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"solutions-guide-instructor-access",children:"Solutions Guide (Instructor Access)"}),"\n",(0,s.jsx)(n.h3,{id:"exercise-31-expected-components",children:"Exercise 3.1 Expected Components"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Simple differential drive robot model"}),"\n",(0,s.jsx)(n.li,{children:"Camera and IMU sensors"}),"\n",(0,s.jsx)(n.li,{children:"Basic navigation controller"}),"\n",(0,s.jsx)(n.li,{children:"World with static obstacles"}),"\n",(0,s.jsx)(n.li,{children:"Valid ROS 2 communication patterns"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"exercise-32-unity-implementation-hints",children:"Exercise 3.2 Unity Implementation Hints"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Use ROS TCP Connector for communication"}),"\n",(0,s.jsx)(n.li,{children:"Implement coordinate system conversion (Unity uses left-handed, ROS uses right-handed)"}),"\n",(0,s.jsx)(n.li,{children:"Use Rigidbody components for physics simulation"}),"\n",(0,s.jsx)(n.li,{children:"Handle message callbacks efficiently"}),"\n",(0,s.jsx)(n.li,{children:"Implement proper connection management"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"exercise-33-domain-randomization-approach",children:"Exercise 3.3 Domain Randomization Approach"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Randomize parameters within reasonable ranges"}),"\n",(0,s.jsx)(n.li,{children:"Balance between exploration and training stability"}),"\n",(0,s.jsx)(n.li,{children:"Track domain parameters for analysis"}),"\n",(0,s.jsx)(n.li,{children:"Implement smooth transitions between domains"}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>o});var s=i(6540);const r={},t=s.createContext(r);function l(e){const n=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);